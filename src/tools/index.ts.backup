import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { SessionManager } from '../utils/session.js';
import { CaptureManager } from '../utils/capture.js';
import { AnalysisEngine } from '../utils/analysis.js';
import { ToolResponse } from '../types/index.js';

export class VDTTools {
  private sessionManager: SessionManager;
  private captureManager: CaptureManager;
  private analysisEngine: AnalysisEngine;

  constructor() {
    this.sessionManager = new SessionManager();
    this.captureManager = new CaptureManager();
    this.analysisEngine = new AnalysisEngine();
  }

  async initialize(): Promise<void> {
    // Initialize core components
  }

  async startSession(params: {
    repoRoot?: string;
    note?: string;
    ttlDays?: number;
  }): Promise<CallToolResult> {
    try {
      const { repoRoot, note, ttlDays = 7 } = params;
      
      const session = await this.sessionManager.createSession(repoRoot, note, ttlDays);
      
      const links = [
        `vdt://sessions/${session.sid}/`,
        this.sessionManager.getResourceLink(session.sid, 'meta.json'),
        this.sessionManager.getResourceLink(session.sid, 'logs/capture.ndjson')
      ];

      const response: ToolResponse = {
        data: {
          sid: session.sid,
          links
        }
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    } catch (error) {
      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Check repository root permissions and disk space'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async doCapture(params: {
    sid: string;
    shell: {
      cwd: string;
      commands?: string[];
      env?: Record<string, string>;
      timeoutSec?: number;
    };
    redact?: {
      patterns?: string[];
    };
  }): Promise<CallToolResult> {
    try {
      const { sid, shell, redact = {} } = params;

      const session = await this.sessionManager.getSession(sid);
      if (!session) {
        throw new Error(`Session ${sid} not found`);
      }

      const sessionDir = this.sessionManager.getSessionDir(sid);
      const result = await this.captureManager.captureShell(sessionDir, shell, redact);

      const response: ToolResponse = {
        data: {
          chunks: result.chunks.map(chunk => 
            this.sessionManager.getResourceLink(sid, chunk)
          ),
          summary: result.summary
        }
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      await this.sessionManager.addError(params.sid, 'do_capture', 'CAPTURE_ERROR',
        error instanceof Error ? error.message : 'Unknown error');

      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Check command permissions and timeout settings. Consider shorter capture duration.'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async analyzeDebugLog(params: {
    sid: string;
    focus?: {
      module?: string;
      func?: string;
      timeRange?: [number, number];
      selectedIds?: string[];
    };
    ruleset?: string;
  }): Promise<CallToolResult> {
    try {
      const { sid, focus, ruleset = 'js-web-default' } = params;

      const session = await this.sessionManager.getSession(sid);
      if (!session) {
        throw new Error(`Session ${sid} not found`);
      }

      const sessionDir = this.sessionManager.getSessionDir(sid);
      const result = await this.analysisEngine.analyzeDebugLog(sessionDir, focus, ruleset);

      const response: ToolResponse = {
        data: {
          findings: result.findings,
          links: result.links.map(link => 
            this.sessionManager.getResourceLink(sid, link)
          )
        }
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      await this.sessionManager.addError(params.sid, 'analyze_debug_log', 'ANALYSIS_ERROR',
        error instanceof Error ? error.message : 'Unknown error');

      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Ensure capture.ndjson exists and contains valid log data'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  // v0.2 HUD Tools
  async hudStart(params: HudStartIn): Promise<CallToolResult> {
    try {
      const session = await this.sessionManager.getSession(params.sid);
      if (!session) {
        throw new Error(`Session ${params.sid} not found`);
      }

      const sessionDir = this.sessionManager.getSessionDir(params.sid);
      const result = await this.hudManager.startHud(params, sessionDir);

      const response: ToolResponse = {
        data: result
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      await this.sessionManager.addError(params.sid, 'hud_start', 'HUD_START_ERROR',
        error instanceof Error ? error.message : 'Unknown error');

      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Check development server configuration and port availability'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async hudStatus(params: { sid: string }): Promise<CallToolResult> {
    try {
      const result = await this.hudManager.getHudStatus(params.sid);

      const response: ToolResponse = {
        data: result
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Check if HUD session exists and is running'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async hudStop(params: { sid: string; saveTrace?: boolean }): Promise<CallToolResult> {
    try {
      const result = await this.hudManager.stopHud(params.sid, params.saveTrace);

      const response: ToolResponse = {
        data: result
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Check if HUD session exists'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async recordStart(params: RecordStartIn): Promise<CallToolResult> {
    try {
      const recordId = `rec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      await this.hudManager.startRecording(params.sid, recordId, params.entryUrl, params.selectors);

      const response: ToolResponse = {
        data: {
          recordId,
          links: [`vdt://sessions/${params.sid}/logs/actions.rec.ndjson`]
        }
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      await this.sessionManager.addError(params.sid, 'record_start', 'RECORD_START_ERROR',
        error instanceof Error ? error.message : 'Unknown error');

      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Ensure HUD session is running and browser is ready'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async recordStop(params: RecordStopIn): Promise<CallToolResult> {
    try {
      const result = await this.hudManager.stopRecording(params.sid, params.recordId, params.export);

      const response: ToolResponse = {
        data: result
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      await this.sessionManager.addError(params.sid, 'record_stop', 'RECORD_STOP_ERROR',
        error instanceof Error ? error.message : 'Unknown error');

      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Check if recording session exists and is active'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async replayRun(params: ReplayRunIn): Promise<CallToolResult> {
    try {
      const result = await this.hudManager.replayScript(params.sid, params.script, params.mode);

      const response: ToolResponse = {
        data: result
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      await this.sessionManager.addError(params.sid, 'replay_run', 'REPLAY_ERROR',
        error instanceof Error ? error.message : 'Unknown error');

      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Check script path and browser availability'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async analyzeWebCapture(params: AnalyzeWebCaptureIn): Promise<CallToolResult> {
    try {
      const session = await this.sessionManager.getSession(params.sid);
      if (!session) {
        throw new Error(`Session ${params.sid} not found`);
      }

      const sessionDir = this.sessionManager.getSessionDir(params.sid);
      const result = await this.webAnalyzer.analyzeWebCapture(sessionDir, params);

      const response: ToolResponse = {
        data: result
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      await this.sessionManager.addError(params.sid, 'analyze_web_capture', 'WEB_ANALYSIS_ERROR',
        error instanceof Error ? error.message : 'Unknown error');

      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Ensure web capture data exists in session logs'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async reasonerRun(params: ReasonerRunIn): Promise<CallToolResult> {
    try {
      if (!this.reasonerAdapter.isAvailable()) {
        throw new Error('No reasoner backends available. Please configure reasoners in .vdt/reasoners.json');
      }

      const session = await this.sessionManager.getSession(params.sid);
      if (!session) {
        throw new Error(`Session ${params.sid} not found`);
      }

      const sessionDir = this.sessionManager.getSessionDir(params.sid);

      // Build reasoner task
      const task = {
        task: params.task,
        sid: params.sid,
        inputs: params.inputs,
        question: params.question,
        constraints: params.constraints,
        model_prefs: {
          effort: (params.args?.effort as 'low' | 'medium' | 'high') || 'medium',
          max_tokens: 4000,
          temperature: 0.2,
        },
        redact: params.redact ?? true,
      };

      // Execute reasoning task
      const result = await this.reasonerAdapter.executeTask(task, sessionDir);

      // Generate response links
      const links = [
        `vdt://sessions/${params.sid}/analysis/reasoner_${params.task}.json`,
      ];

      const response: ToolResponse = {
        data: {
          links,
          result,
        },
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };

    } catch (error) {
      await this.sessionManager.addError(params.sid, 'reasoner_run', 'REASONER_ERROR',
        error instanceof Error ? error.message : 'Unknown error');

      const response: ToolResponse = {
        isError: true,
        message: error instanceof Error ? error.message : 'Unknown error',
        hint: 'Check reasoner configuration and backend availability. Ensure API keys are set for HTTP backends.'
      };

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(response, null, 2)
        }]
      };
    }
  }

  async dispose(): Promise<void> {
    await this.hudManager.dispose();
  }
}